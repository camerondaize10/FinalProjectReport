# Iteration 2

## Step 2

Primary use cases: 

UC-2

UC-4

UC-5

UC-8

## Step 3 

Refinement occurs across the client and server side 

## Step 4

Create a Domain Model for the application

Before starting decomposition we need to identify entities in the domain along with their relationship.


Identify Domain Objects that map to functional requirements

Each element of the application is in a self-contained package. Possibility is that it increases the risk of considering the requirements if domain objects are not considered.


Decompose Domain Objects into general and specialized Components

Domain objects represent complete sets of functionality located within the layers. The components in this pattern are what have been referred to as modules.

## Step 5

Map the system use cases to domain objects
An initial identification has been made by analyzing use cases. 

Decompose the domain objects across the layers to identify layer-specific modules with an explicit interface
All the functionalities are to be identified. This will allow other team members to identify the rest of the modules. We need to test the modules, so a new architectural concern is identified. 

## Step 6

Sketch Views and Record Design Decisions

The domain objects diagram is created, and the sketch of the module view with refined modules that are associated with the primary use cases.

![alt text](https://github.com/camerondaize10/FinalProjectReport/blob/main/Iteration%202/Misc/step%206.PNG)

## Step 7

Perform Analysis of Current Design and Review iteration Goal and Achievement of Design Purpose

The decisions that have been made in iteration 2 provided an initial understanding of the functionality and how it is supported in the system. Also, as part of module identification, we were able to identify a new architectural concern. The design decisions of this iteration were related to the models containing these elements that are listed above and use cases that corresponded to these elements. 

